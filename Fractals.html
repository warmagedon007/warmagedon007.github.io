<!doctype html>
<html>
<head>
    <title>Fractals</title>
    <link rel="stylesheet" href="main_style.css" />
    <style>
        canvas {
            width: 100%;
            height: auto;
            z-index: 1;
            padding: 0px 0px 0px 0px;
            margin: 0px 0px 0px 0px;
        }
        #position {
            z-index: 2;
            position: absolute;
            margin: 5px 0px 0px 5px;
            color:orangered;
        }
    </style>
</head>
<body>
    <h1>Fractals</h1>
    <a href="https://en.wikipedia.org/wiki/Fractal">An explanation about fractals</a>
    <p>
        I implemented the <a href="https://en.wikipedia.org/wiki/Mandelbrot_set">Mandelbrot set</a><br />
    </p>
    <div>
        <canvas>
        </canvas>
    </div>
    <h2 id="position"></h2>
    <script>
        const debug = true;
        var offset = [0, 0], scale = 1, numberOfIterations = 4;
        const canvas = document.getElementsByTagName("canvas")[0].getContext("2d");
        canvas.canvas.width = innerWidth; canvas.canvas.height = innerHeight;
        canvas.canvas.width = canvas.canvas.getBoundingClientRect().width; canvas.canvas.height = canvas.canvas.getBoundingClientRect().height;

        function draw() {
            canvas.clearRect(0, 0, canvas.canvas.width, canvas.canvas.height);
            for (var i = 0; i < canvas.canvas.width; i++) {
                for (var j = 0; j < canvas.canvas.height; j++) {
                    var stw = screenToWorld(i, j);
                    if ((stw[0] >= (-1 / canvas.canvas.width) && stw[0] <= (1 / canvas.canvas.width)) ||
                        (stw[1] >= (-1 / canvas.canvas.width) && stw[1] <= (1 / canvas.canvas.width))) {
                        canvas.fillStyle = "#FFFFFF";
                    }
                    else {
                        var z = stw, n = 0;
                        while (Math.sqrt(Math.pow(z[0], 2) + Math.pow(z[1], 2)) < 2 && n < numberOfIterations) {
                            n++;
                            z = [(Math.pow(z[0], 2) - Math.pow(z[1], 2) + stw[0]), (2 * z[0] * z[1] + stw[1])];
                        }
                        canvas.fillStyle = "#" + ["00", "11", "22", "33", "44", "55", "66", "77", "88", "99", "AA", "BB", "CC", "DD", "EE", "FF"][
                            15 * Math.floor(1 - (numberOfIterations - n) / numberOfIterations)] + "0000";
                    }
                    canvas.fillRect(i, j, 1, 1);
                }
            }
        }

        var v = [0, 0], f = false;
        canvas.canvas.addEventListener("mousedown", e => {
            f = true;
            v = screenToWorld(e.offsetX, e.offsetY);
        });

        canvas.canvas.addEventListener("mousemove", e => {
            var p = document.getElementById("position"), rect = canvas.canvas.getBoundingClientRect();
            p.style.left = e.pageX + "px"; p.style.top = e.pageY + "px";
            var stw = screenToWorld(e.offsetX, e.offsetY);
            p.textContent = stw[0].toFixed(3) + "," + stw[1].toFixed(3);
            if (f) {
                offset[0] -= stw[0] - v[0]; offset[1] -= stw[1] - v[1];
                v = stw;
                draw();
            }
        });

        canvas.canvas.addEventListener("mouseup", e => {
            f = false;
        });

        canvas.canvas.addEventListener("mouseleave", e => {
            f = false;
        });

        function screenToWorld(x, y) {
            return [
                (x - 0.5 * canvas.canvas.width) * (2 * scale / canvas.canvas.width) + offset[0],
                (0.5 * canvas.canvas.height - y) * (2 * scale / canvas.canvas.width) + offset[1]
            ];
        }

        draw();
    </script>
</body>
</html>